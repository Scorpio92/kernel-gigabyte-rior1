/* Copyright (c) 2009-2011, Code Aurora Forum. All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 and
 * only version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 */

#include <linux/delay.h>
#include <linux/module.h>
#include <linux/leds.h>
#include <mach/gpio.h>
#include <mach/pmic.h>
#include "msm_fb.h"

#define CONFIG_FB_MSM_LCDC_AUTO_DETECT

static int prev_bl = 32;

static int spi_cs;
static int spi_sclk;
static int spi_mosi;
static int gpio_backlight_en;
static int gpio_display_reset;

struct lcdc_state_type{
	boolean disp_initialized;
	boolean display_on;
	boolean disp_powered_up;
};

static struct lcdc_state_type lcdc_state = { 0 };
static struct msm_panel_common_pdata *lcdc_pdata;

static __inline__ int  WriteREG_command(unsigned char c1,unsigned char c2)
{
	unsigned char i,j,k;

	j=0x20;
	gpio_set_value_cansleep(spi_sclk, 0); 
        udelay(1);
	gpio_set_value_cansleep(spi_mosi, 0);
        udelay(1);
	gpio_set_value_cansleep(spi_cs, 0);
        udelay(1);
	for(i=0;i<8;i++)
	{
	    	gpio_set_value_cansleep(spi_sclk, 0);
        	udelay(1);
		if(j&0x80)
			gpio_set_value_cansleep(spi_mosi, 1);
		else    
			gpio_set_value_cansleep(spi_mosi, 0);

		udelay(1);
		gpio_set_value_cansleep(spi_sclk, 0);
		k=j<<1;
		gpio_set_value_cansleep(spi_sclk, 1); 
		        udelay(1);
		j=k;
	}

	for(i=0;i<8;i++)
	{
	   	gpio_set_value_cansleep(spi_sclk, 0);
	    	udelay(1);
		if(c1&0x80)
			gpio_set_value_cansleep(spi_mosi, 1);
		else    
			gpio_set_value_cansleep(spi_mosi, 0);
		
		gpio_set_value_cansleep(spi_sclk, 0);
		k=c1<<1;
		udelay(1);
		gpio_set_value_cansleep(spi_sclk, 1); 
		udelay(1);
		c1=k;
	}
	gpio_set_value_cansleep(spi_cs, 1);

	j=0x00;
	gpio_set_value_cansleep(spi_sclk, 0);
	udelay(1);
	gpio_set_value_cansleep(spi_mosi, 0);
	udelay(1);
	gpio_set_value_cansleep(spi_cs, 0);
	for(i=0;i<8;i++)
	{
	    gpio_set_value_cansleep(spi_sclk, 0);
	   	udelay(1);
		if(j&0x80)
			gpio_set_value_cansleep(spi_mosi, 1);
		else    
			gpio_set_value_cansleep(spi_mosi, 0);

		gpio_set_value_cansleep(spi_sclk, 0);
		k=j<<1;
		udelay(1);
		gpio_set_value_cansleep(spi_sclk, 1); 
		udelay(1);
		j=k;
	}
	for(i=0;i<8;i++)
	{
	   	gpio_set_value_cansleep(spi_sclk, 0);
	        udelay(1);
		if(c2&0x80)
			gpio_set_value_cansleep(spi_mosi, 1);
		else    
			gpio_set_value_cansleep(spi_mosi, 0);

		gpio_set_value_cansleep(spi_sclk, 0);
		k=c2<<1;
		udelay(1);
		gpio_set_value_cansleep(spi_sclk, 1); 
		udelay(1);
		c2=k;
	}
	gpio_set_value_cansleep(spi_cs, 1); 
	udelay(1);
	gpio_set_value_cansleep(spi_sclk, 0);
	udelay(1);
	gpio_set_value_cansleep(spi_mosi, 0);
	udelay(1);
	
	return 0;
}

static __inline__  int  WriteREG_para(unsigned char d)
{
	unsigned char i,j,k;
       
	j=0x40;
	gpio_set_value_cansleep(spi_sclk, 0);
	udelay(1);
	gpio_set_value_cansleep(spi_mosi, 0);
	udelay(1);
	gpio_set_value_cansleep(spi_cs, 0);
	for(i=0;i<8;i++)
	{
	        gpio_set_value_cansleep(spi_sclk, 0);
	   	udelay(1);
		if(j&0x80)
			gpio_set_value_cansleep(spi_mosi, 1);
		else    
			gpio_set_value_cansleep(spi_mosi, 0);

		gpio_set_value_cansleep(spi_sclk, 0);
		k=j<<1;
		udelay(1);
		gpio_set_value_cansleep(spi_sclk, 1); 
		udelay(1);
		j=k;
	}
	
	for(i=0;i<8;i++)
	{
	    	gpio_set_value_cansleep(spi_sclk, 0);
	  	udelay(1);
		if(d&0x80)
			gpio_set_value_cansleep(spi_mosi, 1);
		else    
			gpio_set_value_cansleep(spi_mosi, 0);

		gpio_set_value_cansleep(spi_sclk, 0);
		k=d<<1;
		udelay(1);
		gpio_set_value_cansleep(spi_sclk, 1); 
		udelay(1);
		d=k;
	}
	gpio_set_value_cansleep(spi_cs, 1); 
	udelay(1);
	gpio_set_value_cansleep(spi_sclk, 0);
	udelay(1);
	gpio_set_value_cansleep(spi_mosi, 0);
	udelay(1);
	
	return 0;
}

static __inline__ void Write_REG(unsigned char c1, unsigned char c2, unsigned char d)
{
	WriteREG_command(c1,c2);
	WriteREG_para(d);
}

static __inline void otm_lcd_panel_init(void)
{
 	gpio_set_value_cansleep(gpio_display_reset, 1);
	msleep(20);
	gpio_set_value_cansleep(gpio_display_reset, 0);
	msleep(20);
	gpio_set_value_cansleep(gpio_display_reset, 1);
	msleep(200);


msleep(120);

//LV2 Page 1 enable
Write_REG(0xF0, 0x00, 0x55);
Write_REG(0xF0, 0x01, 0xAA);
Write_REG(0xF0, 0x02, 0x52);
Write_REG(0xF0, 0x03, 0x08);
Write_REG(0xF0, 0x04, 0x01);

//AVDD Set AVDD 5.2V
Write_REG(0xB0, 0x00, 0x0D);
Write_REG(0xB0, 0x01, 0x0D);
Write_REG(0xB0, 0x02, 0x0D);

//AVDD ratio
Write_REG(0xB6, 0x00, 0x34);
Write_REG(0xB6, 0x01, 0x34);
Write_REG(0xB6, 0x02, 0x34);
 
//AVEE  -5.2V
Write_REG(0xB1, 0x00,0x0D);
Write_REG(0xB1, 0x01,0x0D);
Write_REG(0xB1, 0x02,0x0D);

//AVEE ratio
Write_REG(0xB7, 0x00,0x34);
Write_REG(0xB7, 0x01,0x34);
Write_REG(0xB7, 0x02,0x34);

//VCL  -2.5V
Write_REG(0xB2, 0x00,0x00);
Write_REG(0xB2, 0x01,0x00);
Write_REG(0xB2, 0x02,0x00);

//VCL ratio
Write_REG(0xB8, 0x00,0x24);
Write_REG(0xB8, 0x01,0x24);
Write_REG(0xB8, 0x02,0x24);


//VGH 15V  (Free pump)
Write_REG(0xBF, 0x00,0x01);
Write_REG(0xB3, 0x00,0x0F);
Write_REG(0xB3, 0x01,0x0F);
Write_REG(0xB3, 0x02,0x0F);

//VGH ratio
Write_REG(0xB9, 0x00,0x34);
Write_REG(0xB9, 0x01,0x34);
Write_REG(0xB9, 0x02,0x34);

//VGL_REG -10V
Write_REG(0xB5, 0x00,0x08);
Write_REG(0xB5, 0x01,0x08);
Write_REG(0xB5, 0x02,0x08);

Write_REG(0xC2, 0x00,0x03);

//VGLX ratio
Write_REG(0xBA, 0x00,0x24);
Write_REG(0xBA, 0x01,0x24);
Write_REG(0xBA, 0x02,0x24);

//VGMP/VGSP 4.5V/0V
Write_REG(0xBC, 0x00,0x00);
Write_REG(0xBC, 0x01,0x78);
Write_REG(0xBC, 0x02,0x00);

//VGMN/VGSN -4.5V/0V
Write_REG(0xBD, 0x00,0x00);
Write_REG(0xBD, 0x01,0x78);
Write_REG(0xBD, 0x02,0x00);

//VCOM -1.325V 
Write_REG(0xBE, 0x00,0x00);
Write_REG(0xBE, 0x01,0x69);

//Gamma Setting
Write_REG(0xD1, 0x00,0x00);
Write_REG(0xD1, 0x01,0x2D);
Write_REG(0xD1, 0x02,0x00);
Write_REG(0xD1, 0x03,0x2E);
Write_REG(0xD1, 0x04,0x00);
Write_REG(0xD1, 0x05,0x32);
Write_REG(0xD1, 0x06,0x00);
Write_REG(0xD1, 0x07,0x44);
Write_REG(0xD1, 0x08,0x00);
Write_REG(0xD1, 0x09,0x53);
Write_REG(0xD1, 0x0A,0x00);
Write_REG(0xD1, 0x0B,0x88);
Write_REG(0xD1, 0x0C,0x00);
Write_REG(0xD1, 0x0D,0xB6);
Write_REG(0xD1, 0x0E,0x00);
Write_REG(0xD1, 0x0F,0xF3);
Write_REG(0xD1, 0x10,0x01);
Write_REG(0xD1, 0x11,0x22);
Write_REG(0xD1, 0x12,0x01);
Write_REG(0xD1, 0x13,0x64);
Write_REG(0xD1, 0x14,0x01);
Write_REG(0xD1, 0x15,0x92);
Write_REG(0xD1, 0x16,0x01);
Write_REG(0xD1, 0x17,0xD4);
Write_REG(0xD1, 0x18,0x02);
Write_REG(0xD1, 0x19,0x07);
Write_REG(0xD1, 0x1A,0x02);
Write_REG(0xD1, 0x1B,0x08);
Write_REG(0xD1, 0x1C,0x02);
Write_REG(0xD1, 0x1D,0x34);
Write_REG(0xD1, 0x1E,0x02);
Write_REG(0xD1, 0x1F,0x5F);
Write_REG(0xD1, 0x20,0x02);
Write_REG(0xD1, 0x21,0x78);
Write_REG(0xD1, 0x22,0x02);
Write_REG(0xD1, 0x23,0x94);
Write_REG(0xD1, 0x24,0x02);
Write_REG(0xD1, 0x25,0xA6);
Write_REG(0xD1, 0x26,0x02);
Write_REG(0xD1, 0x27,0xBB);
Write_REG(0xD1, 0x28,0x02);
Write_REG(0xD1, 0x29,0xCA);
Write_REG(0xD1, 0x2A,0x02);
Write_REG(0xD1, 0x2B,0xDB);
Write_REG(0xD1, 0x2C,0x02);
Write_REG(0xD1, 0x2D,0xE8);
Write_REG(0xD1, 0x2E,0x02);
Write_REG(0xD1, 0x2F,0xF9);
Write_REG(0xD1, 0x30,0x03);
Write_REG(0xD1, 0x31,0x1F);
Write_REG(0xD1, 0x32,0x03);
Write_REG(0xD1, 0x33,0x7F);

Write_REG(0xD2, 0x00,0x00);
Write_REG(0xD2, 0x01,0x2D);
Write_REG(0xD2, 0x02,0x00);
Write_REG(0xD2, 0x03,0x2E);
Write_REG(0xD2, 0x04,0x00);
Write_REG(0xD2, 0x05,0x32);
Write_REG(0xD2, 0x06,0x00);
Write_REG(0xD2, 0x07,0x44);
Write_REG(0xD2, 0x08,0x00);
Write_REG(0xD2, 0x09,0x53);
Write_REG(0xD2, 0x0A,0x00);
Write_REG(0xD2, 0x0B,0x88);
Write_REG(0xD2, 0x0C,0x00);
Write_REG(0xD2, 0x0D,0xB6);
Write_REG(0xD2, 0x0E,0x00);
Write_REG(0xD2, 0x0F,0xF3);
Write_REG(0xD2, 0x10,0x01);
Write_REG(0xD2, 0x11,0x22);
Write_REG(0xD2, 0x12,0x01);
Write_REG(0xD2, 0x13,0x64);
Write_REG(0xD2, 0x14,0x01);
Write_REG(0xD2, 0x15,0x92);
Write_REG(0xD2, 0x16,0x01);
Write_REG(0xD2, 0x17,0xD4);
Write_REG(0xD2, 0x18,0x02);
Write_REG(0xD2, 0x19,0x07);
Write_REG(0xD2, 0x1A,0x02);
Write_REG(0xD2, 0x1B,0x08);
Write_REG(0xD2, 0x1C,0x02);
Write_REG(0xD2, 0x1D,0x34);
Write_REG(0xD2, 0x1E,0x02);
Write_REG(0xD2, 0x1F,0x5F);
Write_REG(0xD2, 0x20,0x02);
Write_REG(0xD2, 0x21,0x78);
Write_REG(0xD2, 0x22,0x02);
Write_REG(0xD2, 0x23,0x94);
Write_REG(0xD2, 0x24,0x02);
Write_REG(0xD2, 0x25,0xA6);
Write_REG(0xD2, 0x26,0x02);
Write_REG(0xD2, 0x27,0xBB);
Write_REG(0xD2, 0x28,0x02);
Write_REG(0xD2, 0x29,0xCA);
Write_REG(0xD2, 0x2A,0x02);
Write_REG(0xD2, 0x2B,0xDB);
Write_REG(0xD2, 0x2C,0x02);
Write_REG(0xD2, 0x2D,0xE8);
Write_REG(0xD2, 0x2E,0x02);
Write_REG(0xD2, 0x2F,0xF9);
Write_REG(0xD2, 0x30,0x03);
Write_REG(0xD2, 0x31,0x1F);
Write_REG(0xD2, 0x32,0x03);
Write_REG(0xD2, 0x33,0x7F);

Write_REG(0xD3, 0x00,0x00);
Write_REG(0xD3, 0x01,0x2D);
Write_REG(0xD3, 0x02,0x00);
Write_REG(0xD3, 0x03,0x2E);
Write_REG(0xD3, 0x04,0x00);
Write_REG(0xD3, 0x05,0x32);
Write_REG(0xD3, 0x06,0x00);
Write_REG(0xD3, 0x07,0x44);
Write_REG(0xD3, 0x08,0x00);
Write_REG(0xD3, 0x09,0x53);
Write_REG(0xD3, 0x0A,0x00);
Write_REG(0xD3, 0x0B,0x88);
Write_REG(0xD3, 0x0C,0x00);
Write_REG(0xD3, 0x0D,0xB6);
Write_REG(0xD3, 0x0E,0x00);
Write_REG(0xD3, 0x0F,0xF3);
Write_REG(0xD3, 0x10,0x01);
Write_REG(0xD3, 0x11,0x22);
Write_REG(0xD3, 0x12,0x01);
Write_REG(0xD3, 0x13,0x64);
Write_REG(0xD3, 0x14,0x01);
Write_REG(0xD3, 0x15,0x92);
Write_REG(0xD3, 0x16,0x01);
Write_REG(0xD3, 0x17,0xD4);
Write_REG(0xD3, 0x18,0x02);
Write_REG(0xD3, 0x19,0x07);
Write_REG(0xD3, 0x1A,0x02);
Write_REG(0xD3, 0x1B,0x08);
Write_REG(0xD3, 0x1C,0x02);
Write_REG(0xD3, 0x1D,0x34);
Write_REG(0xD3, 0x1E,0x02);
Write_REG(0xD3, 0x1F,0x5F);
Write_REG(0xD3, 0x20,0x02);
Write_REG(0xD3, 0x21,0x78);
Write_REG(0xD3, 0x22,0x02);
Write_REG(0xD3, 0x23,0x94);
Write_REG(0xD3, 0x24,0x02);
Write_REG(0xD3, 0x25,0xA6);
Write_REG(0xD3, 0x26,0x02);
Write_REG(0xD3, 0x27,0xBB);
Write_REG(0xD3, 0x28,0x02);
Write_REG(0xD3, 0x29,0xCA);
Write_REG(0xD3, 0x2A,0x02);
Write_REG(0xD3, 0x2B,0xDB);
Write_REG(0xD3, 0x2C,0x02);
Write_REG(0xD3, 0x2D,0xE8);
Write_REG(0xD3, 0x2E,0x02);
Write_REG(0xD3, 0x2F,0xF9);
Write_REG(0xD3, 0x30,0x03);
Write_REG(0xD3, 0x31,0x1F);
Write_REG(0xD3, 0x32,0x03);
Write_REG(0xD3, 0x33,0x7F);

Write_REG(0xD4, 0x00,0x00);
Write_REG(0xD4, 0x01,0x2D);
Write_REG(0xD4, 0x02,0x00);
Write_REG(0xD4, 0x03,0x2E);
Write_REG(0xD4, 0x04,0x00);
Write_REG(0xD4, 0x05,0x32);
Write_REG(0xD4, 0x06,0x00);
Write_REG(0xD4, 0x07,0x44);
Write_REG(0xD4, 0x08,0x00);
Write_REG(0xD4, 0x09,0x53);
Write_REG(0xD4, 0x0A,0x00);
Write_REG(0xD4, 0x0B,0x88);
Write_REG(0xD4, 0x0C,0x00);
Write_REG(0xD4, 0x0D,0xB6);
Write_REG(0xD4, 0x0E,0x00);
Write_REG(0xD4, 0x0F,0xF3);
Write_REG(0xD4, 0x10,0x01);
Write_REG(0xD4, 0x11,0x22);
Write_REG(0xD4, 0x12,0x01);
Write_REG(0xD4, 0x13,0x64);
Write_REG(0xD4, 0x14,0x01);
Write_REG(0xD4, 0x15,0x92);
Write_REG(0xD4, 0x16,0x01);
Write_REG(0xD4, 0x17,0xD4);
Write_REG(0xD4, 0x18,0x02);
Write_REG(0xD4, 0x19,0x07);
Write_REG(0xD4, 0x1A,0x02);
Write_REG(0xD4, 0x1B,0x08);
Write_REG(0xD4, 0x1C,0x02);
Write_REG(0xD4, 0x1D,0x34);
Write_REG(0xD4, 0x1E,0x02);
Write_REG(0xD4, 0x1F,0x5F);
Write_REG(0xD4, 0x20,0x02);
Write_REG(0xD4, 0x21,0x78);
Write_REG(0xD4, 0x22,0x02);
Write_REG(0xD4, 0x23,0x94);
Write_REG(0xD4, 0x24,0x02);
Write_REG(0xD4, 0x25,0xA6);
Write_REG(0xD4, 0x26,0x02);
Write_REG(0xD4, 0x27,0xBB);
Write_REG(0xD4, 0x28,0x02);
Write_REG(0xD4, 0x29,0xCA);
Write_REG(0xD4, 0x2A,0x02);
Write_REG(0xD4, 0x2B,0xDB);
Write_REG(0xD4, 0x2C,0x02);
Write_REG(0xD4, 0x2D,0xE8);
Write_REG(0xD4, 0x2E,0x02);
Write_REG(0xD4, 0x2F,0xF9);
Write_REG(0xD4, 0x30,0x03);
Write_REG(0xD4, 0x31,0x1F);
Write_REG(0xD4, 0x32,0x03);
Write_REG(0xD4, 0x33,0x7F);

Write_REG(0xD5, 0x00,0x00);
Write_REG(0xD5, 0x01,0x2D);
Write_REG(0xD5, 0x02,0x00);
Write_REG(0xD5, 0x03,0x2E);
Write_REG(0xD5, 0x04,0x00);
Write_REG(0xD5, 0x05,0x32);
Write_REG(0xD5, 0x06,0x00);
Write_REG(0xD5, 0x07,0x44);
Write_REG(0xD5, 0x08,0x00);
Write_REG(0xD5, 0x09,0x53);
Write_REG(0xD5, 0x0A,0x00);
Write_REG(0xD5, 0x0B,0x88);
Write_REG(0xD5, 0x0C,0x00);
Write_REG(0xD5, 0x0D,0xB6);
Write_REG(0xD5, 0x0E,0x00);
Write_REG(0xD5, 0x0F,0xF3);
Write_REG(0xD5, 0x10,0x01);
Write_REG(0xD5, 0x11,0x22);
Write_REG(0xD5, 0x12,0x01);
Write_REG(0xD5, 0x13,0x64);
Write_REG(0xD5, 0x14,0x01);
Write_REG(0xD5, 0x15,0x92);
Write_REG(0xD5, 0x16,0x01);
Write_REG(0xD5, 0x17,0xD4);
Write_REG(0xD5, 0x18,0x02);
Write_REG(0xD5, 0x19,0x07);
Write_REG(0xD5, 0x1A,0x02);
Write_REG(0xD5, 0x1B,0x08);
Write_REG(0xD5, 0x1C,0x02);
Write_REG(0xD5, 0x1D,0x34);
Write_REG(0xD5, 0x1E,0x02);
Write_REG(0xD5, 0x1F,0x5F);
Write_REG(0xD5, 0x20,0x02);
Write_REG(0xD5, 0x21,0x78);
Write_REG(0xD5, 0x22,0x02);
Write_REG(0xD5, 0x23,0x94);
Write_REG(0xD5, 0x24,0x02);
Write_REG(0xD5, 0x25,0xA6);
Write_REG(0xD5, 0x26,0x02);
Write_REG(0xD5, 0x27,0xBB);
Write_REG(0xD5, 0x28,0x02);
Write_REG(0xD5, 0x29,0xCA);
Write_REG(0xD5, 0x2A,0x02);
Write_REG(0xD5, 0x2B,0xDB);
Write_REG(0xD5, 0x2C,0x02);
Write_REG(0xD5, 0x2D,0xE8);
Write_REG(0xD5, 0x2E,0x02);
Write_REG(0xD5, 0x2F,0xF9);
Write_REG(0xD5, 0x30,0x03);
Write_REG(0xD5, 0x31,0x1F);
Write_REG(0xD5, 0x32,0x03);
Write_REG(0xD5, 0x33,0x7F);

Write_REG(0xD6, 0x00,0x00);
Write_REG(0xD6, 0x01,0x2D);
Write_REG(0xD6, 0x02,0x00);
Write_REG(0xD6, 0x03,0x2E);
Write_REG(0xD6, 0x04,0x00);
Write_REG(0xD6, 0x05,0x32);
Write_REG(0xD6, 0x06,0x00);
Write_REG(0xD6, 0x07,0x44);
Write_REG(0xD6, 0x08,0x00);
Write_REG(0xD6, 0x09,0x53);
Write_REG(0xD6, 0x0A,0x00);
Write_REG(0xD6, 0x0B,0x88);
Write_REG(0xD6, 0x0C,0x00);
Write_REG(0xD6, 0x0D,0xB6);
Write_REG(0xD6, 0x0E,0x00);
Write_REG(0xD6, 0x0F,0xF3);
Write_REG(0xD6, 0x10,0x01);
Write_REG(0xD6, 0x11,0x22);
Write_REG(0xD6, 0x12,0x01);
Write_REG(0xD6, 0x13,0x64);
Write_REG(0xD6, 0x14,0x01);
Write_REG(0xD6, 0x15,0x92);
Write_REG(0xD6, 0x16,0x01);
Write_REG(0xD6, 0x17,0xD4);
Write_REG(0xD6, 0x18,0x02);
Write_REG(0xD6, 0x19,0x07);
Write_REG(0xD6, 0x1A,0x02);
Write_REG(0xD6, 0x1B,0x08);
Write_REG(0xD6, 0x1C,0x02);
Write_REG(0xD6, 0x1D,0x34);
Write_REG(0xD6, 0x1E,0x02);
Write_REG(0xD6, 0x1F,0x5F);
Write_REG(0xD6, 0x20,0x02);
Write_REG(0xD6, 0x21,0x78);
Write_REG(0xD6, 0x22,0x02);
Write_REG(0xD6, 0x23,0x94);
Write_REG(0xD6, 0x24,0x02);
Write_REG(0xD6, 0x25,0xA6);
Write_REG(0xD6, 0x26,0x02);
Write_REG(0xD6, 0x27,0xBB);
Write_REG(0xD6, 0x28,0x02);
Write_REG(0xD6, 0x29,0xCA);
Write_REG(0xD6, 0x2A,0x02);
Write_REG(0xD6, 0x2B,0xDB);
Write_REG(0xD6, 0x2C,0x02);
Write_REG(0xD6, 0x2D,0xE8);
Write_REG(0xD6, 0x2E,0x02);
Write_REG(0xD6, 0x2F,0xF9);
Write_REG(0xD6, 0x30,0x03);
Write_REG(0xD6, 0x31,0x1F);
Write_REG(0xD6, 0x32,0x03);
Write_REG(0xD6, 0x33,0x7F);



//LV2 Page 0 enable
Write_REG(0xF0, 0x00,0x55);
Write_REG(0xF0, 0x01,0xAA);
Write_REG(0xF0, 0x02,0x52);
Write_REG(0xF0, 0x03,0x08);
Write_REG(0xF0, 0x04,0x00);

Write_REG(0xB0, 0x00,0x00);
Write_REG(0xB0, 0x01,0x08);
Write_REG(0xB0, 0x02,0x08);
Write_REG(0xB0, 0x03,0x08);
Write_REG(0xB0, 0x04,0x08);

//Display control
Write_REG(0xB1, 0x00, 0xCC);
Write_REG(0xB1, 0x01, 0x00);

//Source hold time
Write_REG(0xB6, 0x00,0x05);

//Gate EQ control
Write_REG(0xB7, 0x00,0x70);
Write_REG(0xB7, 0x01,0x70);

//Source EQ control (Mode 2)
Write_REG(0xB8, 0x00,0x01);
Write_REG(0xB8, 0x01,0x03);
Write_REG(0xB8, 0x02,0x03);
Write_REG(0xB8, 0x03,0x03);


//Inversion mode  (2-dot)
Write_REG(0xBC, 0x00,0x02);
Write_REG(0xBC, 0x01,0x00);
Write_REG(0xBC, 0x02,0x00);

//Timing control 4H w/ 4-delay 
Write_REG(0xC9, 0x00,0xD0);
Write_REG(0xC9, 0x01,0x02);
Write_REG(0xC9, 0x02,0x50);
Write_REG(0xC9, 0x03,0x50);
Write_REG(0xC9, 0x04,0x50);

Write_REG(0x35, 0x00,0x00);

Write_REG(0x3A, 0x00,0x77 );

WriteREG_command(0x11, 0x00);
msleep(120);
WriteREG_command(0x29, 0x00);
 msleep(20);


}

static __inline__ int otm_set_backlight(void)
{
	Write_REG(0x51,0x00,0xFF);
	Write_REG(0x53,0x00,0x24);
	Write_REG(0x55,0x00,0x00);

	return 0;
}

static void spi_pin_assign(void)
{
	/* Setting the Default GPIO's */
	spi_mosi	= *(lcdc_pdata->gpio_num);
	spi_sclk	= *(lcdc_pdata->gpio_num + 1);
	spi_cs		= *(lcdc_pdata->gpio_num + 2);
	gpio_backlight_en = *(lcdc_pdata->gpio_num + 3);
	gpio_display_reset = *(lcdc_pdata->gpio_num + 4);
}

static void lcdc_disp_powerup(void)
{
	if (!lcdc_state.disp_powered_up && !lcdc_state.display_on) {
		/* Reset the hardware first */
		/* Include DAC power up implementation here */
	      lcdc_state.disp_powered_up = TRUE;
	}
}

static void lcdc_disp_reginit(void)
{
	if (lcdc_state.disp_powered_up && !lcdc_state.display_on) {
		gpio_set_value_cansleep(spi_cs, 1);	/* cs high */
		msleep(10);
		otm_lcd_panel_init();
		//otm_set_backlight();
		lcdc_state.display_on = TRUE;
	}
}

static int lcdc_panel_on(struct platform_device *pdev)
{
//luke: add for continue
	struct msm_fb_data_type *mfd = platform_get_drvdata(pdev);
	if((lcdc_pdata->cont_splash_enabled)&&(!mfd->cont_splash_done)){
		printk("luke: %s cont_splash_enabled! %d \n",__func__,__LINE__);
        	mfd->cont_splash_done = 1;
        	//return 0;
	}
//luke: add end	
	if (lcdc_pdata->panel_config_gpio){
		lcdc_pdata->panel_config_gpio(1);
	}
	lcdc_disp_powerup();
	lcdc_disp_reginit();	
	lcdc_state.disp_initialized = TRUE;

	return 0;
}

static int lcdc_panel_off(struct platform_device *pdev)
{
	if (lcdc_state.disp_powered_up && lcdc_state.display_on) {

		/* Main panel power off (Pull down reset) */
		WriteREG_command(0x28,00); // Display off
		WriteREG_command(0x10,00); // Enter Standby mode

		gpio_set_value_cansleep(gpio_display_reset, 0);
		lcdc_state.display_on = FALSE;
		lcdc_state.disp_initialized = FALSE;
	}

	return 0;
}

#define LCD_DRIVER_BL 1

static void lcdc_set_backlight(struct msm_fb_data_type *mfd)
{
    if(!LCD_DRIVER_BL)
    {
	int step = 0, i = 0;
	int bl_level = mfd->bl_level;
	/* real backlight level, 1 - max, 16 - min, 32 - off */
	bl_level = 32 - bl_level;
	//printk("%s: prev_bl = %d, bl_level = %d\n", __func__, prev_bl, bl_level);
	if (bl_level > prev_bl) {
		step = bl_level - prev_bl;
		if (bl_level == 32) {
			step--;
		}
	} else if (bl_level < prev_bl) {
		step = bl_level + 31 - prev_bl;
	} else {
		return;
	}

	if (bl_level == 32) {
		/* turn off backlight */
		gpio_set_value_cansleep(gpio_backlight_en, 0);
	} else {
		if (prev_bl == 32) {
			/* turn on backlight */
			gpio_set_value_cansleep(gpio_backlight_en, 1);
			udelay(30);
		}

		/* adjust backlight level */
		for (i = 0; i < step; i++) {
			gpio_set_value_cansleep(gpio_backlight_en, 0);
			udelay(1);
			gpio_set_value_cansleep(gpio_backlight_en, 1);
			udelay(1);
		}
	}
	msleep(1);
	prev_bl = bl_level;
    }else {
	int bl_level = mfd->bl_level;
	//int bl_level = 200;
	gpio_set_value_cansleep(spi_cs, 0);
	Write_REG(0x51,0x00,bl_level);		
	gpio_set_value_cansleep(spi_mosi, 1);
	gpio_set_value_cansleep(spi_cs, 1);
	udelay(10);
	Write_REG(0x53,0x00,0x24);
	Write_REG(0x55,0x00,0x00);
	if(0 == bl_level){
		//Start===Allen
		keyboard_led_light(KEY_LED_USER_LCD, 0);
		//End===Allen
	}else {
		//Start===Allen
		keyboard_led_light(KEY_LED_USER_LCD, 1);
		//End===Allen
	}    
    }

    return;
}

static int __devinit lcdc_probe(struct platform_device *pdev)
{
	printk("%s\n",__func__);
	if (pdev->id == 0) {
		lcdc_pdata = pdev->dev.platform_data;
		spi_pin_assign();
		return 0;
	}
	msm_fb_add_device(pdev);
	return 0;
}

static struct platform_driver this_driver = {
	.probe  = lcdc_probe,
	.driver = {
		.name   = "lcdc_azet_nt35510_wvga_pt", 
	},
};

static struct msm_fb_panel_data lcdc_panel_data = {
	.on = lcdc_panel_on,
	.off = lcdc_panel_off,
	.set_backlight = lcdc_set_backlight,
};

static struct platform_device this_device = {
	.name   = "lcdc_azet_nt35510_wvga_pt",
	.id	= 1,
	.dev	= {
		.platform_data = &lcdc_panel_data,
	}
};

static int __init lcdc_byd_panel_init(void)
{

	int ret;
	struct msm_panel_info *pinfo;
	printk("%s\n",__func__);

#ifdef CONFIG_FB_MSM_LCDC_AUTO_DETECT
	if (msm_fb_detect_client("lcdc_azet_nt35510_wvga_pt")) {
		return 0;
	}
#endif	
	ret = platform_driver_register(&this_driver);
	if (ret)
		return ret;

	pinfo = &lcdc_panel_data.panel_info;
	pinfo->xres = 480;
	pinfo->yres = 800;
	MSM_FB_SINGLE_MODE_PANEL(pinfo);
	pinfo->type = LCDC_PANEL;
	pinfo->pdest = DISPLAY_1;
	pinfo->wait_cycle = 0;
	pinfo->bpp = 24;
	pinfo->fb_num = 2;
	/* 10Mhz mdp_lcdc_pclk and mdp_lcdc_pad_pcl */
	pinfo->clk_rate = 24500000;
	pinfo->bl_max = 255;
	pinfo->bl_min = 1;

	pinfo->lcdc.h_back_porch = 20;		/* hsw = 8 + hbp=16 */
	pinfo->lcdc.h_front_porch = 20;
	pinfo->lcdc.h_pulse_width = 2;
	pinfo->lcdc.v_back_porch = 20;		/* vsw=1 + vbp = 7 */
	pinfo->lcdc.v_front_porch = 20;
	pinfo->lcdc.v_pulse_width = 10;

	pinfo->lcdc.border_clr = 0;			/* blk */
	pinfo->lcdc.underflow_clr = 0xff;	/* blue */
	pinfo->lcdc.hsync_skew = 0;
	ret = platform_device_register(&this_device);
	if (ret) {
		printk(KERN_ERR "%s not able to register the device\n",
			 __func__);
		goto fail_driver;
	}

	return 0;

fail_driver:
	platform_driver_unregister(&this_driver);
	return ret;
}

device_initcall(lcdc_byd_panel_init);
